import{spawnSync as e}from"child_process";import{resolve as t,extname as r}from"path";import{existsSync as s,mkdirSync as i}from"fs";import{install as n}from"source-map-support";import{TestRunner as o}from"@umbra-test/umbra-test-runner";import{ArgumentParser as a}from"argparse";import c from"ansi-escapes";import d from"callsite-record";import h from"chalk";import u from"fast-glob";class l{constructor(){this.started=!1}start(e,t){if(this.started)throw new Error("WriteStreamInterceptor has already been started!");this.started=!0,this.streamToIntercept=e,this.originalStreamWrite=this.streamToIntercept.write,this.streamToIntercept.write=e=>{const r=t(e);return"string"==typeof r&&this.writeDirect(r),!0}}stop(){if(!this.started)throw new Error("WriteStreamInterceptor has not been started!");this.streamToIntercept.write=this.originalStreamWrite,this.started=!1}writeDirect(e){if(!this.started)throw new Error("WriteStreamInterceptor has not been started!");this.originalStreamWrite.apply(this.streamToIntercept,[e])}}class p{constructor(){this.currentIndentLevel=0,this.passes=0,this.failures=0,this.pending=0}initialize(){return console.log(`\n${h.whiteBright("☾")} Umbra Test`),p.drawHorizontalLine(),Promise.resolve()}activeFileChanged(e){this.activeFilePath=e}afterDescribe(e,t){this.currentIndentLevel--}beforeDescribe(e){this.currentIndentLevel++}beforeTest(e){this.pending++,this.currentIndentLevel++}runEnd(e){}runStart(){}testFail(e,t,r){this.pending--,this.failures++,this.currentIndentLevel--}testTimeout(e,t,r){this.pending--,this.failures++,this.currentIndentLevel--}testSkipped(e){this.pending--,this.currentIndentLevel--}testSuccess(e,t){this.pending--,this.passes++,this.currentIndentLevel--}static drawHorizontalLine(){for(let e=0;e<process.stdout.columns-1;e++)process.stdout.write("─");process.stdout.write("\n")}getIndentedText(e,t=0){let r="";for(let e=0;e<this.currentIndentLevel+t;e++)r+=" ";return r+e}}var f;!function(e){e[e.SUCCESS=0]="SUCCESS",e[e.FAIL=1]="FAIL",e[e.SKIPPED=2]="SKIPPED",e[e.TIMEOUT=3]="TIMEOUT"}(f||(f={}));class m extends p{beforeDescribe(e){super.beforeDescribe(e),console.log(this.getIndentedText(h.cyan("⤷")+` ${e}`))}beforeTest(e){super.beforeTest(e),console.log(this.getIndentedText(h.cyan("⤷")+` ${e}`))}testFail(e,t,r){super.testFail(e,t,r),console.log(this.getIndentedText(h.redBright(`✖ FAIL ✖ ${e}`),2)),this.printPrettyStackTrace(t)}testTimeout(e,t,r){super.testTimeout(e,t,r),console.log(this.getIndentedText(h.redBright(`✖ TIMED OUT ✖ ${e}`),2))}runEnd(e){console.log(`Tests completed in ${e.elapsedTimeMs}ms. ${e.totalTests} tests run ${e.totalSuccesses} succeeded ${e.totalFailures} failed.`)}printPrettyStackTrace(e){console.log(e.message)}}const g={basic:m,fancy:class extends p{constructor(e=new l,t=new l){super(),this.timer=null,this.spinnerIndex=0,this.spinnerIcons=["◴","◷","◶","◵"],this.onProcessLog=e=>{},this.stdOutInterceptor=e,this.stdErrInterceptor=t}initialize(){return this.stdOutInterceptor.start(process.stdout,this.onProcessLog),this.stdErrInterceptor.start(process.stderr,this.onProcessLog),this.stdOutInterceptor.writeDirect("[?25l"),this.writeLine(`\n${h.whiteBright("☾")} Umbra Test`),this.writeLine(h.white("⤷ All logs will be intercepted and written to a local file.")),this.drawHorizontalLine(),Promise.resolve()}beforeDescribe(e){this.writeLine(this.getIndentedText(h.cyan("⤷")+` ${e}`)),super.beforeDescribe(e)}beforeTest(e){this.startSpinner(e),super.beforeTest(e)}runEnd(e){this.stdOutInterceptor.writeDirect("[?25h"),this.stdOutInterceptor.stop(),this.stdErrInterceptor.stop()}testFail(e,t,r){this.stopSpinner(f.FAIL),this.stdErrInterceptor.writeDirect(t.message+"\n");const s=d({forError:t}).renderSync({frameSize:3});this.stdErrInterceptor.writeDirect(s+"\n\n"),super.testFail(e,t,r)}testTimeout(e,t,r){this.stopSpinner(f.TIMEOUT),super.testTimeout(e,t,r)}testSkipped(e){this.stopSpinner(f.SKIPPED),super.testSkipped(e)}testSuccess(e,t){this.stopSpinner(f.SUCCESS),super.testSuccess(e,t)}drawHorizontalLine(){for(let e=0;e<process.stdout.columns;e++)this.stdOutInterceptor.writeDirect("─");this.stdOutInterceptor.writeDirect("\n")}writeLine(e){this.stdOutInterceptor.writeDirect(e+"\n")}startSpinner(e){this.stdOutInterceptor.writeDirect(this.getIndentedText(h.yellow(this.spinnerIcons[this.spinnerIndex])+" "+e)),this.stdOutInterceptor.writeDirect(c.cursorLeft),this.stdOutInterceptor.writeDirect(c.cursorForward(this.currentIndentLevel+1)),this.timer=setInterval(()=>{this.stdOutInterceptor.writeDirect(c.cursorBackward(1)),this.spinnerIndex=(this.spinnerIndex+1)%(this.spinnerIcons.length-1),this.stdOutInterceptor.writeDirect(h.yellow(this.spinnerIcons[this.spinnerIndex]))},200)}stopSpinner(e){clearInterval(this.timer),this.stdOutInterceptor.writeDirect(c.cursorBackward(1)),e===f.FAIL?this.stdOutInterceptor.writeDirect(h.redBright("✘")):e===f.SUCCESS?this.stdOutInterceptor.writeDirect(h.greenBright("✓")):e===f.TIMEOUT&&this.stdOutInterceptor.writeDirect(h.redBright("⏲")),this.stdOutInterceptor.writeDirect(c.cursorNextLine),this.stdOutInterceptor.writeDirect("\n")}}};const b={input:[],debug:!1,debugBreak:!1,watch:!1,cacheDir:".umbra-cache",timeoutMs:{it:100,before:100,beforeEach:100,after:100,afterEach:100},reporting:{outputPath:void 0,reporters:[]},parallel:{idempotentFiles:!1,idempotentTests:!1}};n();const I=(new class{constructor(){this.argsParser=new a({description:"Run tests using the Umbra test framework."}),this.addGeneralOptions(),this.addTimeoutOptions(),this.addReportingOptions(),this.addParallelOptions()}parse(){const e=this.argsParser.parseArgs();return this.cloneNonNullValues({input:e.input[0].length>0?e.input[0]:void 0,cacheDir:e.cacheDir,configPath:t(e.configPath),debug:e.debug,debugBreak:e.debugBrk,watch:e.watch,timeoutMs:this.cloneNonNullValues({it:e.timeoutMs||e.itTimeoutMs,before:e.timeoutMs||e.beforeTimeoutMs,beforeEach:e.timeoutMs||e.beforeEachTimeoutMs,after:e.timeoutMs||e.afterTimeoutMs,afterEach:e.timeoutMs||e.afterEachTimeoutMs}),reporting:this.cloneNonNullValues({reporters:e.reporter?[e.reporter]:[],outputPath:e.outputPath}),parallel:this.cloneNonNullValues({idempotentFiles:e.idempotentFiles,idempotentTests:e.idempotentTests})})}cloneNonNullValues(e){const t={};for(const r of Object.keys(e)){const s=e[r];void 0!==s&&null!=s&&(("boolean"!=typeof s||s)&&(t[r]=s))}return Object.keys(t).length>0?t:void 0}addGeneralOptions(){this.argsParser.addArgument("input",{help:"Files, or globs, to run with the Umbra Test Runner",required:!1,action:"append",nargs:"*"}),this.argsParser.addArgument(["-d","--debug"],{help:"Enables the Node debugger",required:!1,action:"storeTrue",dest:"debug"}),this.argsParser.addArgument(["-db","--debug-brk"],{help:"Enables the Node debugger, breaking once the first test is evaluated",required:!1,action:"storeTrue",dest:"debugBrk"}),this.argsParser.addArgument(["-w","--watch"],{help:"Enables watch mode, which will evaluate all tests first and then again once changes occur.",required:!1,action:"storeTrue",dest:"watch"}),this.argsParser.addArgument(["-c","--config"],{help:"Sets the config file path.",required:!1,dest:"configPath",defaultValue:"./umbra.config.ts"}),this.argsParser.addArgument(["--cacheDir"],{help:"The directory in which to store umbra cache files used for dynamic optimization.",required:!1,dest:"cacheDir"})}addTimeoutOptions(){this.argsParser.addArgument(["--timeoutMs"],{help:"Specifies the general asynchronous timeout value in milliseconds. This affects *all* async methods (it, before, after, etc.)",required:!1,dest:"timeoutMs"});for(const e of["it","before","beforeEach","after","afterEach"])this.argsParser.addArgument([`--${e}TimeoutMs`],{help:`Specifies the asynchronous timeout value for \`${e}\` blocks in milliseconds. This overrides general settings.`,required:!1,dest:`${e}TimeoutMs`})}addReportingOptions(){this.argsParser.addArgument(["-o","--outputPath"],{help:"The output directory to write the final results to.",required:!1,dest:"outputPath"}),this.argsParser.addArgument(["-r","--reporter"],{help:"The reporter to use.",required:!1,dest:"reporter"})}addParallelOptions(){this.argsParser.addArgument(["--idempotentFiles"],{help:"If set, files are treated as idempotent (meaning other file execution does not affect it).",required:!1,action:"storeTrue",dest:"idempotentFiles"}),this.argsParser.addArgument(["--idempotentTests"],{help:"If set, tests are treated as idempotent (meaning other test execution does not affect it). Requires idempotent files.",required:!1,action:"storeTrue",dest:"idempotentTests"})}}).parse(),w=new class{merge(e,...t){for(const r of t)for(const t in r)if(r.hasOwnProperty(t)){const s=r[t];if(void 0===s)continue;"timeoutMs"===t&&"number"==typeof s?e.timeoutMs={it:s,before:s,beforeEach:s,after:s,afterEach:s}:e[t]=r[t]}return e}};let T;if(s(I.configPath)){const n=I.cacheDir?I.cacheDir:b.cacheDir;s(n)||i(n);let o=I.configPath;"ts"===r(I.configPath)&&(o=t(n,"config.js"),e("tsc",["--outFile",o,I.configPath],{stdio:"inherit"}));const a=require(o);T=w.merge(b,a,I)}else T=w.merge(b,I);const S=new o({timeoutMs:T.timeoutMs,stopOnFirstFail:!1}),P=T.reporting.reporters;let D;D=0===P.length?[new m]:P.map(e=>{try{return require(e)}catch(t){if(g[e])return new g[e];throw new Error(`Unable to load reporter: ${e}`)}});for(const e of D)S.on("activeFileChanged",e.activeFileChanged.bind(e)),S.on("beforeTest",e.beforeTest.bind(e)),S.on("testSuccess",e.testSuccess.bind(e)),S.on("testFail",e.testFail.bind(e)),S.on("testTimeout",e.testTimeout.bind(e)),S.on("beforeDescribe",e.beforeDescribe.bind(e)),S.on("afterDescribe",e.afterDescribe.bind(e));const E=S.it.only.bind(S),O=S.describe.only.bind(S),v=["it","describe","after","afterEach","before","beforeEach"];for(const e of v)global[e]=S[e].bind(S);global.it.only=E,global.describe.only=O,global.__testRunner=S;const y=new class{constructor(e){this.testRunner=e}resolveGlob(e){return u(e).then(e=>{for(const r of e){const e=t(r.toString());this.testRunner.setCurrentFile(e),require(e)}})}}(S);Promise.all(D.map(e=>e.initialize())).then(()=>y.resolveGlob(T.input)).then(()=>{for(const e of D)e.runStart()}).then(()=>S.run()).then(e=>{for(const t of D)t.runEnd(e)}).catch(e=>{console.error(e),process.exit(1)});
