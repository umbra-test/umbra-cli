import{spawnSync as t}from"child_process";import{resolve as e,extname as r}from"path";import{existsSync as s,mkdirSync as i}from"fs";import{TestRunner as n}from"umbra-test-runner";import{ArgumentParser as o}from"argparse";import a from"chalk";import c from"ansi-escapes";import h from"callsite-record";import d from"fast-glob";class u{constructor(){this.started=!1}start(t,e){if(this.started)throw new Error("WriteStreamInterceptor has already been started!");this.started=!0,this.streamToIntercept=t,this.originalStreamWrite=this.streamToIntercept.write,this.streamToIntercept.write=t=>{const r=e(t);return"string"==typeof r&&this.writeDirect(r),!0}}stop(){if(!this.started)throw new Error("WriteStreamInterceptor has not been started!");this.streamToIntercept.write=this.originalStreamWrite,this.started=!1}writeDirect(t){if(!this.started)throw new Error("WriteStreamInterceptor has not been started!");this.originalStreamWrite.apply(this.streamToIntercept,[t])}}var l;!function(t){t[t.SUCCESS=0]="SUCCESS",t[t.FAIL=1]="FAIL",t[t.SKIPPED=2]="SKIPPED",t[t.TIMEOUT=3]="TIMEOUT"}(l||(l={}));class p{constructor(t=new u,e=new u){this.timer=null,this.currentIndentLevel=0,this.lines=[],this.spinnerIndex=0,this.spinnerIcons=["‚ó¥","‚ó∑","‚ó∂","‚óµ"],this.activeFileChanged=t=>{this.activeFilePath=t,this.lines.push(a.cyan(">>")+` ${this.activeFilePath}`)},this.afterDescribe=(t,e)=>{this.currentIndentLevel--},this.beforeDescribe=t=>{this.writeLine(this.getIndentedText(a.cyan("‚§∑")+` ${t}`)),this.currentIndentLevel++},this.beforeTest=t=>{this.startSpinner(t),this.pending++,this.currentIndentLevel++},this.runEnd=t=>{this.stdOutInterceptor.writeDirect("[?25h"),this.stdOutInterceptor.stop(),this.stdErrInterceptor.stop()},this.runStart=()=>{},this.testFail=(t,e,r)=>{this.stopSpinner(l.FAIL);const s=h({forError:e}).renderSync({frameSize:3});this.stdErrInterceptor.writeDirect(s+"\n\n"),this.pending--,this.failures++,this.currentIndentLevel--},this.testTimeout=(t,e,r)=>{this.stopSpinner(l.TIMEOUT),this.pending--,this.failures++,this.currentIndentLevel--},this.testSkipped=t=>{this.stopSpinner(l.SKIPPED),this.pending--,this.currentIndentLevel--},this.testSuccess=(t,e)=>{this.stopSpinner(l.SUCCESS),this.pending--,this.passes++,this.currentIndentLevel--},this.passes=0,this.failures=0,this.pending=0,this.onProcessLog=t=>{},this.stdOutInterceptor=t,this.stdErrInterceptor=e}initialize(){return this.stdOutInterceptor.start(process.stdout,this.onProcessLog),this.stdErrInterceptor.start(process.stderr,this.onProcessLog),this.stdOutInterceptor.writeDirect("[?25l"),this.writeLine(`\n${a.whiteBright("‚òæ")} Umbra Test`),this.writeLine(a.white("‚§∑ All logs will be intercepted and written to a local file.")),this.drawHorizontalLine(),Promise.resolve()}drawHorizontalLine(){for(let t=0;t<process.stdout.columns;t++)this.stdOutInterceptor.writeDirect("‚îÄ");this.stdOutInterceptor.writeDirect("\n")}writeLine(t){this.stdOutInterceptor.writeDirect(t+"\n")}startSpinner(t){this.stdOutInterceptor.writeDirect(this.getIndentedText(a.yellow(this.spinnerIcons[this.spinnerIndex])+" "+t)),this.stdOutInterceptor.writeDirect(c.cursorLeft),this.stdOutInterceptor.writeDirect(c.cursorForward(this.currentIndentLevel+1)),this.timer=setInterval(()=>{this.stdOutInterceptor.writeDirect(c.cursorBackward(1)),this.spinnerIndex=(this.spinnerIndex+1)%(this.spinnerIcons.length-1),this.stdOutInterceptor.writeDirect(a.yellow(this.spinnerIcons[this.spinnerIndex]))},200)}stopSpinner(t){clearInterval(this.timer),this.stdOutInterceptor.writeDirect(c.cursorBackward(1)),t===l.FAIL?this.stdOutInterceptor.writeDirect(a.redBright("‚úò")):t===l.SUCCESS?this.stdOutInterceptor.writeDirect(a.greenBright("‚úì")):t===l.TIMEOUT&&this.stdOutInterceptor.writeDirect(a.redBright("‚è≤")),this.stdOutInterceptor.writeDirect(c.cursorNextLine),this.stdOutInterceptor.writeDirect("\n")}getIndentedText(t){let e="";for(let t=0;t<this.currentIndentLevel;t++)e+=" ";return e+t}}const f={fancy:p};const m={input:[],debug:!1,debugBreak:!1,watch:!1,cacheDir:".umbra-cache",timeoutMs:{it:100,before:100,beforeEach:100,after:100,afterEach:100},reporting:{outputPath:void 0,reporters:[]},parallel:{idempotentFiles:!1,idempotentTests:!1}},g=(new class{constructor(){this.argsParser=new o({description:"Run tests using the Umbra test framework."}),this.addGeneralOptions(),this.addTimeoutOptions(),this.addReportingOptions(),this.addParallelOptions()}parse(){const t=this.argsParser.parseArgs();return this.cloneNonNullValues({input:t.input[0].length>0?t.input[0]:void 0,cacheDir:t.cacheDir,configPath:e(t.configPath),debug:t.debug,debugBreak:t.debugBrk,watch:t.watch,timeoutMs:this.cloneNonNullValues({it:t.timeoutMs||t.itTimeoutMs,before:t.timeoutMs||t.beforeTimeoutMs,beforeEach:t.timeoutMs||t.beforeEachTimeoutMs,after:t.timeoutMs||t.afterTimeoutMs,afterEach:t.timeoutMs||t.afterEachTimeoutMs}),reporting:this.cloneNonNullValues({reporters:t.reporter?[t.reporter]:[],outputPath:t.outputPath}),parallel:this.cloneNonNullValues({idempotentFiles:t.idempotentFiles,idempotentTests:t.idempotentTests})})}cloneNonNullValues(t){const e={};for(const r of Object.keys(t)){const s=t[r];void 0!==s&&null!=s&&(("boolean"!=typeof s||s)&&(e[r]=s))}return Object.keys(e).length>0?e:void 0}addGeneralOptions(){this.argsParser.addArgument("input",{help:"Files, or globs, to run with the Umbra Test Runner",required:!1,action:"append",nargs:"*"}),this.argsParser.addArgument(["-d","--debug"],{help:"Enables the Node debugger",required:!1,action:"storeTrue",dest:"debug"}),this.argsParser.addArgument(["-db","--debug-brk"],{help:"Enables the Node debugger, breaking once the first test is evaluated",required:!1,action:"storeTrue",dest:"debugBrk"}),this.argsParser.addArgument(["-w","--watch"],{help:"Enables watch mode, which will evaluate all tests first and then again once changes occur.",required:!1,action:"storeTrue",dest:"watch"}),this.argsParser.addArgument(["-c","--config"],{help:"Sets the config file path.",required:!1,dest:"configPath",defaultValue:"./umbra.config.ts"}),this.argsParser.addArgument(["--cacheDir"],{help:"The directory in which to store umbra cache files used for dynamic optimization.",required:!1,dest:"cacheDir"})}addTimeoutOptions(){this.argsParser.addArgument(["--timeoutMs"],{help:"Specifies the general asynchronous timeout value in milliseconds. This affects *all* async methods (it, before, after, etc.)",required:!1,dest:"timeoutMs"});for(const t of["it","before","beforeEach","after","afterEach"])this.argsParser.addArgument([`--${t}TimeoutMs`],{help:`Specifies the asynchronous timeout value for \`${t}\` blocks in milliseconds. This overrides general settings.`,required:!1,dest:`${t}TimeoutMs`})}addReportingOptions(){this.argsParser.addArgument(["-o","--outputPath"],{help:"The output directory to write the final results to.",required:!1,dest:"outputPath"}),this.argsParser.addArgument(["-r","--reporter"],{help:"The reporter to use.",required:!1,dest:"reporter"})}addParallelOptions(){this.argsParser.addArgument(["--idempotentFiles"],{help:"If set, files are treated as idempotent (meaning other file execution does not affect it).",required:!1,action:"storeTrue",dest:"idempotentFiles"}),this.argsParser.addArgument(["--idempotentTests"],{help:"If set, tests are treated as idempotent (meaning other test execution does not affect it). Requires idempotent files.",required:!1,action:"storeTrue",dest:"idempotentTests"})}}).parse(),w=new class{merge(t,...e){for(const r of e)for(const e in r)if(r.hasOwnProperty(e)){const s=r[e];if(void 0===s)continue;"timeoutMs"===e&&"number"==typeof s?t.timeoutMs={it:s,before:s,beforeEach:s,after:s,afterEach:s}:t[e]=r[e]}return t}};let I;if(s(g.configPath)){const n=g.cacheDir?g.cacheDir:m.cacheDir;s(n)||i(n);let o=g.configPath;"ts"===r(g.configPath)&&(o=e(n,"config.js"),t("tsc",["--outFile",o,g.configPath],{stdio:"inherit"}));const a=require(o);I=w.merge(m,a,g)}else I=w.merge(m,g);const b=new n({timeoutMs:I.timeoutMs,stopOnFirstFail:!1}),T=I.reporting.reporters;let P;P=0===T.length?[new p]:T.map(t=>{try{return require(t)}catch(e){if(f[t])return new f[t];throw new Error(`Unable to load reporter: ${t}`)}});for(const t of P)b.on("activeFileChanged",t.activeFileChanged),b.on("beforeTest",t.beforeTest),b.on("testSuccess",t.testSuccess),b.on("testFail",t.testFail),b.on("testTimeout",t.testTimeout),b.on("beforeDescribe",t.beforeDescribe),b.on("afterDescribe",t.afterDescribe);const S=["it","describe","after","afterEach","before","beforeEach"];for(const t of S)global[t]=b[t];global.__testRunner=b;const E=new class{constructor(t){this.testRunner=t}resolveGlob(t){return d(t).then(t=>{for(const r of t){const t=e(r.toString());this.testRunner.setCurrentFile(t),require(t)}})}}(b);Promise.all(P.map(t=>t.initialize())).then(()=>E.resolveGlob(I.input)).then(()=>{for(const t of P)t.runStart()}).then(()=>b.run()).then(t=>{for(const e of P)e.runEnd(t)}).catch(t=>{console.error(t),process.exit(1)});
